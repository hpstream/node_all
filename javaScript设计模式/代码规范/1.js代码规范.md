# 1.为什要遵守代码规范
软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：

 -  花时间学习和理解这个问题
 -  花时间是了解应该解决的问题代码
 -  还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。

**另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。**

你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：

-  bug是暴露的
-  新功能被添加到应用程序
-  程序在新的环境下工作（例如，市场上出现新想浏览器）
-  代码改变用途
-  代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言

**由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。**

> 可维护的代码意味着：
-  可读的
-  一致的
-  可预测的
- 看上去就像是同一个人写的
-  已记录

# 2. 编写代码需遵守的几个原则
**提示：** 不遵守这些原则代码也能运行起来。只是可能出现难以维护的现象。规范就像一种模式，大家按照一种模式来，那么阅读其他人的代码，成本就降低了。


## 编写代码注意事项：

### 1.尽量减少声明全局变量

### 2. 定义变量是，尽量放到顶部

    function func() {
        var a = 1,
            b = 2,
            sum = a + b,
            myobject = {},
            i,
            j;
        // function body...
    }
注意：在es6中，使用let 定义，可能出现'暂时性死区', 具体想知道什么叫做'暂时性死区' , 请查看阮一峰 [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/let)

### 3.for循环(for Loops)
    // 次佳的循环
    for (var i = 0; i < myarray.length; i++) {
    // 使用myarray[i]做点什么
    }
    //更好的方式
    for (var i = 0, max = myarray.length; i < max; i++) {
    // 使用myarray[i]做点什么
    }

**JSLint提示您这样做，原因是++和–-促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手
如果你直接无视它，JSLint的plusplus选项会是false（默认是default）。**

还有两种变化的形式，其又有了些微改进，因为：

- 少了一个变量(无max)
- 向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率

        //第一种变化的形式：
        var i, myarray = [];
        for (i = myarray.length; i–-;) {
        // 使用myarray[i]做点什么
        }

        //第二种使用while循环：

        var myarray = [],
        i = myarray.length;
        while (i–-) {
        // 使用myarray[i]做点什么
        }
**面两种情况优于前面两种情况。**
### 4.for-in循环(for-in Loops)

for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。

>从技术上将，你可以使用for-in循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。

有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性

    // 对象
    var man = {
        hands: 2,
        legs: 2,
        heads: 1
    };

    // 在代码的某个地方
    // 一个方法添加给了所有对象
    if (typeof Object.prototype.clone === "undefined") {
        Object.prototype.clone = function () {};
    }
    ====================================================================
    // for-in 循环
    for (var i in man) {
    if (man.hasOwnProperty(i)) { // 过滤
        console.log(i, ":", man[i]);
    }
    }
    /* 控制台显示结果
    hands : 2
    legs : 2
    heads : 1
    */
    ==========================================================================
    // 反面例子:
    // for-in loop without checking hasOwnProperty()
    for (var i in man) {
    console.log(i, ":", man[i]);
    }
    /*
    控制台显示结果
    hands : 2
    legs : 2
    heads : 1
    clone: function()
    */

### 5.（不）扩展内置原型((Not) Augmenting Built-in Prototypes)

增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。


**因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：**

 - 可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，- 你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。
 - 如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。
 - 你清楚地文档记录并和团队交流了变化。

        if (typeof Object.protoype.myMethod !== "function") {
            Object.protoype.myMethod = function () {
                // 实现...
            };
        }
一般情况下，强烈不建议使用

### 6.避免隐式类型转换(Avoiding Implied Typecasting )

JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。

    var zero = 0;
    if (zero === false) {
    // 不执行，因为zero为0, 而不是false
    }

    // 反面示例
    if (zero == false) {
    // 执行了...
    }

### 7. 避免(Avoiding) eval()

如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：

    // 反面示例
    var property = "name";
    alert(eval("obj." + property));

    // 更好的
    var property = "name";
    alert(obj[property]);
