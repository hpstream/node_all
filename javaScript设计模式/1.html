1.javascripts中的设计模式

1.历史

设置模式存在的原因是为了代码复用，增加可维护性。
原则：
1.开闭原则 对扩展开放，对修改关闭
2.里式转原则 ，子类继承父类
3.依赖倒转原则 
4.接口隔离原则
5.合成聚合原则
6.迪米特原则(最少知识原则)

1.单例模式  在先创建实例的过程中，先判断是否存在，不存在，则创建实例

定义出命名空间
(扩充作用域链)
1.单例模式的作用
    1.模块间通信。
    2.系统中某个类的对象只能存在一个。
    3.保护自己的属性和方法。
2.注意事项：
    1.注意this的使用
    2.闭包容易造成内存泄漏，不需要的赶快干掉。
    3.注意new的成本。（继承）


=============================================
<script>
        init,render,bind,updated;    
</script>
单例模式在开发过程中的作用： 
我们经常在开发过程中，害怕命名冲突，或者全局变量被污染。
这个时候使用我们需要使用'单例模式' 进行模块化开发。
单例与单例之间进行通信。通过分别调用对方的方法即可。

(开发过程中，字符串使用单引号，因为如果是双引号，系统会转化成单引号)
2.构造函数模式
 构造函数模式的作用和注意事项
 模式作用:
 1.用于创建特定 类型的对象。
 2.第一次声明的时候给对象赋值。
 3.自己声明构造函数，赋予属性和方法。
 注意事项：
 1.声明函数的时候处理业务逻辑。
 2.区分和单例模的区别，配合单例实现初始化。
 3.构造函数以大写首字母开头
 4.注意new的成本。
 <script>
     //使用 隐式new方式
     function Strucfn(){
           //如果 this 不止向 Strucfn 构造函数，自己帮他new
            if(!(this instanceof Strucfn)){
                return new Strucfn();
            }
     }
 </script>
3.建造者模式  vue属于建造者模式

代码实践，和总结

4.工厂模式
模式作用
1.对象的构造十分复杂
2.需要依赖具体的环境创建不同的实例。
3.处理大量具有相同属性的小对象。

注意事项
1.不能滥用工厂，有时候仅仅是给代码增加复杂度。

var a = function(){}
a.prototype = {b:function(){console.log(this)}}
a.prototype.constructor = a
var dd= new a()


var entity =  {};
var factory = function(){
    this.use = function(prame,option){
        entity[prame](option);
    }
    this.add = function(prama,fn){
        entiti[prama] = fn;
    }
}

5. 外观模式

模式作用: 
1.在设计初期，设计应该有意识的将不同的两个层分离，比如经典的三层结构。
2.在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外端F可以
提供一个简单的接口，减少他们之间的依赖。
3.在维护一个遗留的大型系统时，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码
提供比较清晰的接口，让新系统和Facade对象交互。
注意事项：
1.外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的
可能性。

6. 代理模式
模式作用:
    1.远程代理(一个对象将不同空间的对象进行局部代理)
    2.虚拟代理（根据需要创建开销开大的对象如渲染网页暂时用站位代替真图）
    3.安全代理(控制真实对象的访问权限)
    4.智能指引（调用对象代理处理另外一些事情如垃圾回收机制）
注意事项:
    1.不能滥用代理，有时候仅仅是代码增加复杂度。

7.代理模式（发布订阅模式）
 
模式作用：
1.支持简单的广播通信，自动通知所有已经订阅过的对象。
2.页面载入后目标对象很容易与观察者存在一种动态关联，增加灵活性。
3.目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。

注意事项：
1.监听要在触发前。

8.策略模式
模式作用:
1.所有的这些算法都是做相同的事情，只是实现不同。
2.以相同的方式调用所有的方法，减少了各种算法类与算法类之间的耦合。
3.单独定义算法类，也方便了单元测试。
注意事项:
1，不仅仅可以封装算法了，也可以用来封装几乎任何类型的规则，是要在分析过程
中需要在不同时间应用不同的业务规则，就可以考虑时要用策略模式来处理各种变化。

9.命令模式
1.将函数的封装，请求，调用结合为一体
2.调用具体的函数解耦命令对象与接收对象。
3.提高程序模块化的灵活性。

注意 事项：
1.不需要接口一致，直接调用函数即可，以避免造成浪费。

10.迭代器模式
模式作用
1.为遍历不同的集合结构提供一个统一接口，从而支持同样的算法在不同的集合结构上进行炒作。
2.对于集合内部结果常常变化各异，我们不想暴露去内部结构的话,但是又想响应客户
代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式
注意事项：
1.一般的迭代器，我们至少要有两个方法，hasNext(),Next()。这样子才做到遍历所有对象
2.遍历的同事迭代器所在的集合结构可能会导致问题（比如删除操作）

11.职责链模式

模式作用：
1.dom 的冒泡有类似职责链
2.node 当controller中有很多负责操作逻辑的时候拆分中间件。
3.解耦发送者和接受者
注意事项：
1.JavaScript中的每一次[.]是有代价的，要在必要的时候时候用。


12.适配器模式

模式作用

注意事项




















