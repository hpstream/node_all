1.javascripts中的设计模式

1.历史

设置模式存在的原因是为了代码复用，增加可维护性。
原则：
1.开闭原则 对扩展开放，对修改关闭
2.里式转原则 ，子类继承父类
3.依赖倒转原则 
4.接口隔离原则
5.合成聚合原则
6.迪米特原则(最少知识原则)

1.单例模式  在先创建实例的过程中，先判断是否存在，不存在，则创建实例

定义出命名空间
(扩充作用域链)
1.单例模式的作用
    1.模块间通信。
    2.系统中某个类的对象只能存在一个。
    3.保护自己的属性和方法。
2.注意事项：
    1.注意this的使用
    2.闭包容易造成内存泄漏，不需要的赶快干掉。
    3.注意new的成本。（继承）


=============================================
<script>
        init,render,bind,updated;    
</script>
单例模式在开发过程中的作用： 
我们经常在开发过程中，害怕命名冲突，或者全局变量被污染。
这个时候使用我们需要使用'单例模式' 进行模块化开发。
单例与单例之间进行通信。通过分别调用对方的方法即可。

(开发过程中，字符串使用单引号，因为如果是双引号，系统会转化成单引号)
2.构造函数模式
 构造函数模式的作用和注意事项
 模式作用:
 1.用于创建特定 类型的对象。
 2.第一次声明的时候给对象赋值。
 3.自己声明构造函数，赋予属性和方法。
 注意事项：
 1.声明函数的时候处理业务逻辑。
 2.区分和单例模的区别，配合单例实现初始化。
 3.构造函数以大写首字母开头
 4.注意new的成本。
 <script>
     //使用 隐式new方式
     function Strucfn(){
           //如果 this 不止向 Strucfn 构造函数，自己帮他new
            if(!(this instanceof Strucfn)){
                return new Strucfn();
            }
     }
 </script>
3.建造者模式  vue属于建造者模式

代码实践，和总结

4.工厂模式
模式作用
1.对象的构造十分复杂
2.需要依赖具体的环境创建不同的实例。
3.处理大量具有相同属性的小对象。

注意事项
1.不能滥用工厂，有时候仅仅是给代码增加复杂度。

var a = function(){}
a.prototype = {b:function(){console.log(this)}}
a.prototype.constructor = a
var dd= new a()


var entity =  {};
var factory = function(){
    this.use = function(prame,option){
        entity[prame](option);
    }
    this.add = function(prama,fn){
        entiti[prama] = fn;
    }
}

5. 外观模式
